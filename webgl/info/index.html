<html>
<head>
<title>WebGL Info</title>
<style>
.highlight {
  background-color: yellow;
}
</style>
</head>

<body>
<script>
if (!String.prototype.format) {
  String.prototype.format = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != "undefined"
        ? args[number]
        : match
      ;
    });
  };
}

if (!Object.keys) {
  Object.keys = function (object) {
    var keys = [];

    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
  }
}

function toggleClass(el, className) {
  if (el.className.indexOf(className) >= 0) {
    el.className = el.className.replace(className,"");
  } else {
    el.className  += className;
  }
}

function getParam(context, str) {
  ret = context.getParameter(str);
  if (ret)
    return ret;
  else
    return "None"
}

function commasToBr(array) {
  var s = "";
  for (var i in array) {
    s += array[i] + "<br />";
  }
  return s;
}
</script>

<script>
var ctxTypes = {
  "WebGL1": ["webgl",,"experimental-webgl", "moz-webgl","webkit-3d"],
  "WebGL2": ["webgl2", "experimental-webgl2"],
}
var categories = Object.keys(ctxTypes);
var info = new Array();
var lines = 0;

for (var i = 0; i < categories.length; i++) {
  var category = categories[i];
  ctxType = ctxTypes[category];
  var ctx = getContext(category, ctxType);
  if (ctx) {
    info[category].push(["Version", getParam(ctx, ctx.VERSION)]);
    info[category].push(["Shading Language Version", getParam(ctx, ctx.SHADING_LANGUAGE_VERSION)]);

    info[category].push(["Vendor", getParam(ctx, ctx.VENDOR)]);
    info[category].push(["Renderer", getParam(ctx, ctx.RENDERER)]);

    var dri = ctx.getExtension("WEBGL_debug_renderer_info");
    info[category].push(["Unmasked Vendor", getParam(ctx, dri.UNMASKED_VENDOR_WEBGL)]);
    info[category].push(["Unmasked Renderer", getParam(ctx, dri.UNMASKED_RENDERER_WEBGL)]);

    info[category].push(["RGBA Bits", getParam(ctx, ctx.RED_BITS) + ", " + getParam(ctx, ctx.GREEN_BITS) + ", " + getParam(ctx, ctx.BLUE_BITS) + ", " + getParam(ctx, ctx.ALPHA_BITS)]);
    info[category].push(["Depth Bits", getParam(ctx, ctx.DEPTH_BITS)]);

    info[category].push(["Max Vertex Attribs", getParam(ctx, ctx.MAX_VERTEX_ATTRIBS)]);
    info[category].push(["Max Vertex Texture Image Units", getParam(ctx, ctx.MAX_VERTEX_TEXTURE_IMAGE_UNITS)]);
    info[category].push(["Max Varying Vectors", getParam(ctx, ctx.MAX_VARYING_VECTORS)]);
    info[category].push(["Max Uniform Vectors", getParam(ctx, ctx.MAX_VERTEX_UNIFORM_VECTORS)]);

    info[category].push(["Max Combined Texture Image Units", getParam(ctx, ctx.MAX_COMBINED_TEXTURE_IMAGE_UNITS)]);
    info[category].push(["Max Texture Size", getParam(ctx, ctx.MAX_TEXTURE_SIZE)]);
    info[category].push(["Max Cube Map Texture Size", getParam(ctx, ctx.MAX_CUBE_MAP_TEXTURE_SIZE)]);

    info[category].push(["Max Render Buffer Size", getParam(ctx, ctx.MAX_RENDERBUFFER_SIZE)]);
    info[category].push(["Max Viewport Dimensions", commasToBr(getParam(ctx, ctx.MAX_VIEWPORT_DIMS))]);
    info[category].push(["Aliased Line Width Range", commasToBr(getParam(ctx, ctx.ALIASED_LINE_WIDTH_RANGE))]);
    info[category].push(["Aliased Point Size Range", commasToBr(getParam(ctx, ctx.ALIASED_POINT_SIZE_RANGE))]);
    info[category].push(["Supported Extensions", commasToBr(ctx.getSupportedExtensions())]);
    info[category].push(["Compressed Texture Formats", commasToBr(getParam(ctx, ctx.COMPRESSED_TEXTURE_FORMATS))]);

    shaderTypes = ["VERTEX_SHADER", "FRAGMENT_SHADER"];
    precisionTypes = ["LOW_INT", "MEDIUM_INT", "HIGH_INT", "LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT"];

    for (var j = 0; j < shaderTypes.length; j++) {
      for (var k = 0; k < precisionTypes.length; k++) {
        pf = ctx.getShaderPrecisionFormat(eval("ctx." + shaderTypes[j]), eval("ctx." + precisionTypes[k]));
        info[category].push(["precisionFormat of {0} in {1}".format(precisionTypes[k], shaderTypes[j]), "rangeMin: {0}, rangeMax: {1}, precision: {2}".format(pf.rangeMin, pf.rangeMax, pf.precision)]);
      }
    }
  }
}

// UI
var h1 = document.createElement("h1");
h1.align = "center";
h1.innerHTML = "WebGL Info";
document.body.appendChild(h1);

// table
var table = document.createElement("table");
table.align = "center";
table.style.width = "80%";
table.setAttribute("border", "1");
document.body.appendChild(table);

addLine("Category", "Key", "Value");

for (i = 0; i < info[categories[0]].length; i++) {
  var same = true;
  var value = info[categories[0]][i];
  for (j = 1; j < categories.length; j++) {
    if (info[categories[j]].length <= i || info[categories[j]][i][1] != info[categories[0]][i][1]) {
      same = false;
      break;
    }
  }
  if (same) {
    addLine("Common", info["WebGL1"][i][0], info["WebGL1"][i][1]);
  } else {
    for (k = 0; k < categories.length; k++) {
      category = categories[k];
      if (info[category].length > i)
        addLine(category, info[category][i][0], info[category][i][1]);
    }
  }

}

function getContext(category, ctxTypes) {
  var ctx;
  var canvas = document.createElement("canvas");
  info[category] = new Array();
  ctxTypeStr = "None";
  for (var i = 0; i < ctxTypes.length; i++) {
    try {
      ctxTmp = canvas.getContext(ctxTypes[i]);
      if (ctxTmp) {
        if (ctxTypeStr == "None") {
          ctxTypeStr = ctxType[i];
        } else {
          ctxTypeStr += ", " + ctxType[i];
        }
        ctx = ctxTmp;
      }
    } catch (e) {}
  }
  info[category].push(["contextType", ctxTypeStr]);
  return ctx;
}

function addLine() {
  var tr = table.insertRow(table.rows.length);
  tr.onclick = function() { toggleClass(this, "highlight"); };
  for (var i = 0; i < arguments.length; i++) {
    var td = tr.insertCell(i);
    td.innerHTML = arguments[i];
    if (lines == 0) {
      td.style.fontWeight = "bold";
    }
    if (i == 0)
      td.style.width = "10%";
    else if (i == 1)
      td.style.width = "20%";
    else if (i == 2)
      td.style.width = "70%";
  }
  lines++;
}
</script>
</body>
</html>
